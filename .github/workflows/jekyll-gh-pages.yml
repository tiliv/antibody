# This default workflow has been modified:
# 1) The root for the site is set to ./docs instead of the repository root.
# 2) A git metrics report is generated and provided before the Jekyll build.

# Sample workflow for building and deploying a Jekyll site to GitHub Pages
name: Deploy Jekyll with GitHub Pages dependencies preinstalled

on:
  # Runs on pushes targeting the default branch
  push:
    branches: ["main"]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: read
  pages: write
  id-token: write

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  # Build job
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Pages
        uses: actions/configure-pages@v5

      - name: Generate/patch git metrics
        shell: bash
        run: |
          set -euo pipefail
          ROOT="docs"
          DATA="$ROOT/_data"
          TRANS="$ROOT/_transparency"
          CACHE="$TRANS/cache"
          BUILDDIR="$TRANS/build"
          mkdir -p "$DATA" "$CACHE" "$BUILDDIR"

          SNAP="$DATA/git.yml"                       # full current snapshot
          LAST_REV_FILE="$CACHE/last_rev"
          CACHED="$CACHE/git.yml"                    # prior snapshot (cached)
          NOW="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          DELTA="$BUILDDIR/$NOW.yml"                 # slim delta report

          # Seed current snapshot from cache if present, else empty skeleton
          if [[ -f "$CACHED" ]]; then
            cp "$CACHED" "$SNAP"
          else
            printf "pages:\n" > "$SNAP"
          fi

          # Determine baseline rev
          if [[ -s "$LAST_REV_FILE" ]]; then
            BASE="$(cat "$LAST_REV_FILE")"
          else
            # First run: use the root commit as baseline so we recompute everything once
            BASE="$(git rev-list --max-parents=0 HEAD)"
          fi

          # Compute changed/renamed/deleted files under docs/
          # Use NUL delim to be safe
          mapfile -d '' CHANGED < <(
            git diff --name-status -z "$BASE"..HEAD -- "$ROOT" || true
          )

          # Prepare delta file
          {
            echo "at: \"$NOW\""
            echo "base: \"$BASE\""
            echo "head: \"$(git rev-parse HEAD)\""
            echo "changed:"
          } > "$DELTA"

          # Helpers
          esc() { sed -e 's/\\/\\\\/g' -e 's/"/\\"/g'; }
          remove_block() {
            # $1: path (relative to docs)
            awk -v tgt="$1" '
              BEGIN{inblk=0}
              /^  - path: "/{
                if($0 ~ "  - path: \"" tgt "\""){
                  inblk=1; next
                } else if(inblk==1){
                  inblk=0
                }
              }
              { if(inblk==0) print }
            ' "$SNAP" > "$SNAP.tmp" && mv "$SNAP.tmp" "$SNAP"
          }

          add_block() {
            # $1: repo path (full), $2: rel path (under docs)
            local f="$1" rel="$2"
            IFS='|' read -r sha name email date < <(
              git log -1 --pretty='format:%H|%aN|%aE|%cI' -- "$f" || echo "|||"
            )
            local adds=0 dels=0
            if [[ -n "${sha:-}" ]]; then
              read -r adds dels < <(
                git show --numstat --format= -- "$sha" -- "$f" \
                | awk '{a+=$1;b+=$2} END{printf "%s %s", a+0, b+0}'
              )
            fi
            {
              echo "  - path: \"$(printf %s "$rel" | esc)\""
              echo "    last_sha: \"$(printf %s "$sha" | esc)\""
              echo "    last_author: \"$(printf %s "$name" | esc)\""
              echo "    last_email: \"$(printf %s "$email" | esc)\""
              echo "    last_changed: \"$(printf %s "$date" | esc)\""
              echo "    last_additions: $adds"
              echo "    last_deletions: $dels"
            } >> "$SNAP"
          }

          # Track whether we had any deltas
          ANY=0

          # Iterate status entries: they come as pairs <STATUS>\0<PATH>\0 or for renames <STATUS>\0<OLD>\0<NEW>\0
          i=0
          while (( i < ${#CHANGED[@]} )); do
            status="${CHANGED[$i]}"; ((i++))
            code="${status%%$'\t'*}" || true
            # For simplicity, split fields by tab in a POSIX-safe way:
            IFS=$'\t' read -r code rest <<<"$status"
            if [[ "$code" == R* ]]; then
              # rename: next two entries are old and new
              old="${CHANGED[$i]}"; ((i++))
              new="${CHANGED[$i]}"; ((i++))
              rel_old="${old#$ROOT/}"; rel_new="${new#$ROOT/}"
              # Remove old block; add new block
              remove_block "$rel_old"
              add_block "$new" "$rel_new"
              {
                echo "  - op: rename"
                echo "    from: \"$(printf %s "$rel_old" | esc)\""
                echo "    to: \"$(printf %s "$rel_new" | esc)\""
              } >> "$DELTA"
              ANY=1
            else
              path="${CHANGED[$i]}"; ((i++))
              rel="${path#$ROOT/}"
              case "$code" in
                D)
                  # Deleted: drop from snapshot
                  remove_block "$rel"
                  {
                    echo "  - op: delete"
                    echo "    path: \"$(printf %s "$rel" | esc)\""
                  } >> "$DELTA"
                  ANY=1
                  ;;
                A|M|T)
                  # Added/Modified/Type change: (re)compute block
                  remove_block "$rel"
                  add_block "$path" "$rel"
                  {
                    echo "  - op: upsert"
                    echo "    path: \"$(printf %s "$rel" | esc)\""
                  } >> "$DELTA"
                  ANY=1
                  ;;
                *)
                  # Other statuses ignored
                  :
                  ;;
              esac
            fi
          done

          # If first run (no diff), build full snapshot once
          if [[ "$ANY" -eq 0 && ! -f "$CACHED" ]]; then
            # NUL-safe full list
            : > "$SNAP"
            echo "pages:" >> "$SNAP"
            git ls-files -z -- "$ROOT" | while IFS= read -r -d '' f; do
              rel="${f#$ROOT/}"
              remove_block "$rel" || true
              add_block "$f" "$rel"
            done
            # Record a delta note
            {
              echo "  - op: init"
              echo "    count: $(git ls-files -- "$ROOT" | wc -l | tr -d ' ')"
            } >> "$DELTA"
          fi

          # Update cache payloads for next run
          cp "$SNAP" "$CACHED"
          git rev-parse HEAD > "$LAST_REV_FILE"

          # Optional: show a summary
          echo "Wrote snapshot: $SNAP"
          echo "Wrote delta:    $DELTA"

      - name: Build with Jekyll
        uses: actions/jekyll-build-pages@v1
        with:
          source: ./docs
          destination: ./_site
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3

  # Deployment job
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
